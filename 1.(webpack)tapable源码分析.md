## tapable 介绍
> Webpack 本质上是一种事件流的机制，它的工作流程就是将各个插件串联起来，而实现这一切的核心就是 tapable，Webpack 中最核心的，负责编译的 Compiler 和负责创建 bundles 的 Compilation 都是 tapable 构造函数的实例。

> 在webpack@4.29.6的源码中，可以看到很多`Sync`、`Async`开头，以`Hook`结尾的方法。这些都是`tapable`库的核心类，为我们提供不同的事件流执行机制，我们称为“钩子”。

```
const {
	Tapable,
	SyncHook,
	SyncBailHook,
	AsyncParallelHook,
	AsyncSeriesHook
} = require("tapable");
```
>> 实现事件流机制的`钩子`大方向可以分为两个类别，“同步”和“异步”，异步又分为两个类别，“并行”和“串行”，而“同步”的钩子都是串行的。常用钩子如下图：

![Image text](https://raw.githubusercontent.com/hpysirius/notes_2019/master/assets/mylogo.jpeg)



### 1.SyncHook
> `SyncHook`为串行同步执行，不关心事件处理函数的返回值，在触发事件之后，会按照事件注册的先后顺序执行所有的事件处理函数。
```
// SyncHook 钩子的使用
const { SyncHook }  = require('tapable');

let queue = new SyncHook(['name', 'name2']);

// 订阅
queue.tap('1', (name, name1) => {
    console.log(name, name1, '1');
    return '1';
})
queue.tap('2', name => {
    console.log(name, '2');
})
queue.tap('3', name => {
    console.log(name, '3');
})

// 发布
queue.call('hpysirius', 'hpysirius1');


// node syncHook执行该文件
// 执行结果
// 传入的参数需要和new实例的时候保持一致，否则获取不到多传的参数
// hpysirius hpysirius1 1
// hpysirius 2
// hpysirius 3
```
### 原理
```
class SyncHook_MY{
    constructor(){
        this.hooks = [];
    }

    // 订阅
    tap(name, fn){
        this.hooks.push(fn);
    }

    // 发布
    call(){
        this.hooks.forEach(hook => hook(...arguments));
    }
}
```